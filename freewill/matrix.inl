// matrix.inl: Matrix Maths Inline Functions
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(_MATRIX_INLINE__)
#define _MATRIX_INLINE__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _sin sin
#define _cos cos

/*inline float _sin(float x)
{
	float y;
	__asm {
		fld x
		fsin
		fstp y
	}
	return y;
}

inline float _cos(float x)
{
	float y;
	__asm {
		fld x
		fcos
		fstp y
	}
	return y;
}*/

inline void _Identity(FWMATRIX M)
{
	static FWDOUBLE IDNT[16] = { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f };
	memcpy(M, IDNT, sizeof(FWMATRIX));
}

inline void _InverseOrthogonal(FWMATRIX M)
{
	FWDOUBLE fAux;
	fAux = M[1][0]; M[1][0] = M[0][1]; M[0][1] = fAux;
	fAux = M[2][0]; M[2][0] = M[0][2]; M[0][2] = fAux;
	fAux = M[2][1]; M[2][1] = M[1][2]; M[1][2] = fAux;
	FWDOUBLE A30 = -M[0][0] * M[3][0] - M[1][0] * M[3][1] - M[2][0] * M[3][2];
	FWDOUBLE A31 = -M[0][1] * M[3][0] - M[1][1] * M[3][1] - M[2][1] * M[3][2];
	FWDOUBLE A32 = -M[0][2] * M[3][0] - M[1][2] * M[3][1] - M[2][2] * M[3][2];
	M[3][0] = A30;
	M[3][1] = A31;
	M[3][2] = A32;
}

inline void _Inverse(FWMATRIX A)
{
	// trans = transposed pSrc
	FWMATRIX trans;	// transposed source matrix
	for(int i = 0; i < 4; i ++)
		for(int j = 0; j < 4; j ++)
			trans[i][j] = A[j][i];

	double tmp[12];		// temp array for pairs

	// calculate pairs for first 8 elements (cofactors)
	tmp[0] = trans[2][2] * trans[3][3];
	tmp[1] = trans[2][3] * trans[3][2];
	tmp[2] = trans[2][1] * trans[3][3];
	tmp[3] = trans[2][3] * trans[3][1];
	tmp[4] = trans[2][1] * trans[3][2];
	tmp[5] = trans[2][2] * trans[3][1];
	tmp[6] = trans[2][0] * trans[3][3];
	tmp[7] = trans[2][3] * trans[3][0];
	tmp[8] = trans[2][0] * trans[3][2];
	tmp[9] = trans[2][2] * trans[3][0];
	tmp[10] = trans[2][0] * trans[3][1];
	tmp[11] = trans[2][1] * trans[3][0];

	// calculate first 8 elements (cofactors)
	A[0][0]  = tmp[0] * trans[1][1] + tmp[3] * trans[1][2] + tmp[4] * trans[1][3];
	A[0][0] -= tmp[1] * trans[1][1] + tmp[2] * trans[1][2] + tmp[5] * trans[1][3];
	A[0][1]  = tmp[1] * trans[1][0] + tmp[6] * trans[1][2] + tmp[9] * trans[1][3];
	A[0][1] -= tmp[0] * trans[1][0] + tmp[7] * trans[1][2] + tmp[8] * trans[1][3];
	A[0][2]  = tmp[2] * trans[1][0] + tmp[7] * trans[1][1] + tmp[10] * trans[1][3];
	A[0][2] -= tmp[3] * trans[1][0] + tmp[6] * trans[1][1] + tmp[11] * trans[1][3];
	A[0][3]  = tmp[5] * trans[1][0] + tmp[8] * trans[1][1] + tmp[11] * trans[1][2];
	A[0][3] -= tmp[4] * trans[1][0] + tmp[9] * trans[1][1] + tmp[10] * trans[1][2];
	A[1][0]  = tmp[1] * trans[0][1] + tmp[2] * trans[0][2] + tmp[5] * trans[0][3];
	A[1][0] -= tmp[0] * trans[0][1] + tmp[3] * trans[0][2] + tmp[4] * trans[0][3];
	A[1][1]  = tmp[0] * trans[0][0] + tmp[7] * trans[0][2] + tmp[8] * trans[0][3];
	A[1][1] -= tmp[1] * trans[0][0] + tmp[6] * trans[0][2] + tmp[9] * trans[0][3];
	A[1][2]  = tmp[3] * trans[0][0] + tmp[6] * trans[0][1] + tmp[11] * trans[0][3];
	A[1][2] -= tmp[2] * trans[0][0] + tmp[7] * trans[0][1] + tmp[10] * trans[0][3];
	A[1][3]  = tmp[4] * trans[0][0] + tmp[9] * trans[0][1] + tmp[10] * trans[0][2];
	A[1][3] -= tmp[5] * trans[0][0] + tmp[8] * trans[0][1] + tmp[11] * trans[0][2];

	// calculate pairs for second 8 elements (cofactors)
	tmp[0] = trans[0][2] * trans[1][3];
	tmp[1] = trans[0][3] * trans[1][2];
	tmp[2] = trans[0][1] * trans[1][3];
	tmp[3] = trans[0][3] * trans[1][1];
	tmp[4] = trans[0][1] * trans[1][2];
	tmp[5] = trans[0][2] * trans[1][1];
	tmp[6] = trans[0][0] * trans[1][3];
	tmp[7] = trans[0][3] * trans[1][0];
	tmp[8] = trans[0][0] * trans[1][2];
	tmp[9] = trans[0][2] * trans[1][0];
	tmp[10] = trans[0][0] * trans[1][1];
	tmp[11] = trans[0][1] * trans[1][0];

	// calculate second 8 elements (cofactors)
	A[2][0]  = tmp[0] * trans[3][1] + tmp[3] * trans[3][2] + tmp[4] * trans[3][3];
	A[2][0] -= tmp[1] * trans[3][1] + tmp[2] * trans[3][2] + tmp[5] * trans[3][3];
	A[2][1]  = tmp[1] * trans[3][0] + tmp[6] * trans[3][2] + tmp[9] * trans[3][3];
	A[2][1] -= tmp[0] * trans[3][0] + tmp[7] * trans[3][2] + tmp[8] * trans[3][3];
	A[2][2]  = tmp[2] * trans[3][0] + tmp[7] * trans[3][1] + tmp[10] * trans[3][3];
	A[2][2] -= tmp[3] * trans[3][0] + tmp[6] * trans[3][1] + tmp[11] * trans[3][3];
	A[2][3]  = tmp[5] * trans[3][0] + tmp[8] * trans[3][1] + tmp[11] * trans[3][2];
	A[2][3] -= tmp[4] * trans[3][0] + tmp[9] * trans[3][1] + tmp[10] * trans[3][2];
	A[3][0]  = tmp[2] * trans[2][2] + tmp[5] * trans[2][3] + tmp[1] * trans[2][1];
	A[3][0] -= tmp[4] * trans[2][3] + tmp[0] * trans[2][1] + tmp[3] * trans[2][2];
	A[3][1]  = tmp[8] * trans[2][3] + tmp[0] * trans[2][0] + tmp[7] * trans[2][2];
	A[3][1] -= tmp[6] * trans[2][2] + tmp[9] * trans[2][3] + tmp[1] * trans[2][0];
	A[3][2]  = tmp[6] * trans[2][1] + tmp[11] * trans[2][3] + tmp[3] * trans[2][0];
	A[3][2] -= tmp[10] * trans[2][3] + tmp[2] * trans[2][0] + tmp[7] * trans[2][1];
	A[3][3]  = tmp[10] * trans[2][2] + tmp[4] * trans[2][0] + tmp[9] * trans[2][1];
	A[3][3] -= tmp[8] * trans[2][1] + tmp[11] * trans[2][2] + tmp[5] * trans[2][0];

	// calculate determinant
	double det = 1.f / (trans[0][0] * A[0][0] + trans[0][1] * A[0][1] + trans[0][2] * A[0][2] + trans[0][3] * A[0][3]);

	// multiplivate each item by the determinant
	for (int i = 0; i < 4; i++)
		for (int j = 0; i < 4; i++)
			A[i][j] *= det;
}

/*inline void _InverseOrthogonal(FWMATRIX12 M)
{
	FWDOUBLE (*m)[3] = (FWDOUBLE(*)[3])M;

	FWDOUBLE fAux;
	fAux = m[1][0]; m[1][0] = m[0][1]; m[0][1] = fAux;
	fAux = m[2][0]; m[2][0] = m[0][2]; m[0][2] = fAux;
	fAux = m[2][1]; m[2][1] = m[1][2]; m[1][2] = fAux;
	FWDOUBLE A30 = -m[0][0] * m[3][0] - m[1][0] * m[3][1] - m[2][0] * m[3][2];
	FWDOUBLE A31 = -m[0][1] * m[3][0] - m[1][1] * m[3][1] - m[2][1] * m[3][2];
	FWDOUBLE A32 = -m[0][2] * m[3][0] - m[1][2] * m[3][1] - m[2][2] * m[3][2];
	m[3][0] = A30;
	m[3][1] = A31;
	m[3][2] = A32;
}

inline void _InverseOrthogonal(FWMATRIX9 M)
{
	FWDOUBLE fAux;
	fAux = M[1][0]; M[1][0] = M[0][1]; M[0][1] = fAux;
	fAux = M[2][0]; M[2][0] = M[0][2]; M[0][2] = fAux;
	fAux = M[2][1]; M[2][1] = M[1][2]; M[1][2] = fAux;
}*/

inline void _MatrixRotationAxis(FWMATRIX M, FWVECTOR *p, FWDOUBLE fAngle)
{
	memset(M, 0, sizeof(FWMATRIX));

	FWDOUBLE s = _sin(fAngle);
	FWDOUBLE c = _cos(fAngle);
	FWDOUBLE u = 1 - c;
	FWDOUBLE len = sqrt(p->x * p->x + p->y * p->y + p->z * p->z);
	FWDOUBLE x = p->x / len;
	FWDOUBLE y = p->y / len;
	FWDOUBLE z = p->z / len;

	M[0][0] = x * x * u + c;
	M[0][1] = x * y * u + z * s;
	M[0][2] = x * z * u - y * s;
	
	M[1][0] = y * x * u - z * s;
	M[1][1] = y * y * u + c;
	M[1][2] = y * z * u + x * s;
	
	M[2][0] = z * x * u + y * s;
	M[2][1] = z * y * u - x * s;
	M[2][2] = z * z * u + c;

	M[3][3] = 1.0f;
}

// M1 * M2 -> M2
inline void _Multiply(FWMATRIX M1, FWMATRIX M2)
{
	assert(M1[0][3] == 0 && M1[1][3] == 0 && M1[2][3] == 0 && M1[3][3] == 1);
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE x0, x1, x2;

	x0 = M1[0][0] * M2[0][0] + M1[1][0] * M2[0][1] + M1[2][0] * M2[0][2];
	x1 = M1[0][1] * M2[0][0] + M1[1][1] * M2[0][1] + M1[2][1] * M2[0][2];
	x2 = M1[0][2] * M2[0][0] + M1[1][2] * M2[0][1] + M1[2][2] * M2[0][2];
	M2[0][0] = x0; M2[0][1] = x1; M2[0][2] = x2;

	x0 = M1[0][0] * M2[1][0] + M1[1][0] * M2[1][1] + M1[2][0] * M2[1][2];
	x1 = M1[0][1] * M2[1][0] + M1[1][1] * M2[1][1] + M1[2][1] * M2[1][2];
	x2 = M1[0][2] * M2[1][0] + M1[1][2] * M2[1][1] + M1[2][2] * M2[1][2];
	M2[1][0] = x0; M2[1][1] = x1; M2[1][2] = x2;

	x0 = M1[0][0] * M2[2][0] + M1[1][0] * M2[2][1] + M1[2][0] * M2[2][2];
	x1 = M1[0][1] * M2[2][0] + M1[1][1] * M2[2][1] + M1[2][1] * M2[2][2];
	x2 = M1[0][2] * M2[2][0] + M1[1][2] * M2[2][1] + M1[2][2] * M2[2][2];
	M2[2][0] = x0; M2[2][1] = x1; M2[2][2] = x2;

	x0 = M1[0][0] * M2[3][0] + M1[1][0] * M2[3][1] + M1[2][0] * M2[3][2] + M1[3][0];
	x1 = M1[0][1] * M2[3][0] + M1[1][1] * M2[3][1] + M1[2][1] * M2[3][2] + M1[3][1];
	x2 = M1[0][2] * M2[3][0] + M1[1][2] * M2[3][1] + M1[2][2] * M2[3][2] + M1[3][2];
	M2[3][0] = x0; M2[3][1] = x1; M2[3][2] = x2;
}

// M1 * M2 -> M1
inline void _MultiplyR(FWMATRIX M1, FWMATRIX M2)
{
	assert(M1[0][3] == 0 && M1[1][3] == 0 && M1[2][3] == 0 && M1[3][3] == 1);
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE x0, x1, x2;

	x0 = M1[0][0] * M2[3][0] + M1[1][0] * M2[3][1] + M1[2][0] * M2[3][2] + M1[3][0];
	x1 = M1[0][1] * M2[3][0] + M1[1][1] * M2[3][1] + M1[2][1] * M2[3][2] + M1[3][1];
	x2 = M1[0][2] * M2[3][0] + M1[1][2] * M2[3][1] + M1[2][2] * M2[3][2] + M1[3][2];
	M1[3][0] = x0; M1[3][1] = x1; M1[3][2] = x2;

	x0 = M1[0][0] * M2[0][0] + M1[1][0] * M2[0][1] + M1[2][0] * M2[0][2];
	x1 = M1[0][0] * M2[1][0] + M1[1][0] * M2[1][1] + M1[2][0] * M2[1][2];
	x2 = M1[0][0] * M2[2][0] + M1[1][0] * M2[2][1] + M1[2][0] * M2[2][2];
	M1[0][0] = x0; M1[1][0] = x1; M1[2][0] = x2;

	x0 = M1[0][1] * M2[0][0] + M1[1][1] * M2[0][1] + M1[2][1] * M2[0][2];
	x1 = M1[0][1] * M2[1][0] + M1[1][1] * M2[1][1] + M1[2][1] * M2[1][2];
	x2 = M1[0][1] * M2[2][0] + M1[1][1] * M2[2][1] + M1[2][1] * M2[2][2];
	M1[0][1] = x0; M1[1][1] = x1; M1[2][1] = x2;

	x0 = M1[0][2] * M2[0][0] + M1[1][2] * M2[0][1] + M1[2][2] * M2[0][2];
	x1 = M1[0][2] * M2[1][0] + M1[1][2] * M2[1][1] + M1[2][2] * M2[1][2];
	x2 = M1[0][2] * M2[2][0] + M1[1][2] * M2[2][1] + M1[2][2] * M2[2][2];
	M1[0][2] = x0; M1[1][2] = x1; M1[2][2] = x2;
}

// M1 * M2 -> M3
inline void _Multiply(FWMATRIX M1, FWMATRIX M2, FWMATRIX M3)
{
	assert(M1[0][3] == 0 && M1[1][3] == 0 && M1[2][3] == 0 && M1[3][3] == 1);
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	M3[0][0] = M1[0][0] * M2[0][0] + M1[1][0] * M2[0][1] + M1[2][0] * M2[0][2];
	M3[0][1] = M1[0][1] * M2[0][0] + M1[1][1] * M2[0][1] + M1[2][1] * M2[0][2];
	M3[0][2] = M1[0][2] * M2[0][0] + M1[1][2] * M2[0][1] + M1[2][2] * M2[0][2];
	M3[0][3] = 0;

	M3[1][0] = M1[0][0] * M2[1][0] + M1[1][0] * M2[1][1] + M1[2][0] * M2[1][2];
	M3[1][1] = M1[0][1] * M2[1][0] + M1[1][1] * M2[1][1] + M1[2][1] * M2[1][2];
	M3[1][2] = M1[0][2] * M2[1][0] + M1[1][2] * M2[1][1] + M1[2][2] * M2[1][2];
	M3[1][3] = 0;

	M3[2][0] = M1[0][0] * M2[2][0] + M1[1][0] * M2[2][1] + M1[2][0] * M2[2][2];
	M3[2][1] = M1[0][1] * M2[2][0] + M1[1][1] * M2[2][1] + M1[2][1] * M2[2][2];
	M3[2][2] = M1[0][2] * M2[2][0] + M1[1][2] * M2[2][1] + M1[2][2] * M2[2][2];
	M3[2][3] = 0;

	M3[3][0] = M1[0][0] * M2[3][0] + M1[1][0] * M2[3][1] + M1[2][0] * M2[3][2] + M1[3][0];
	M3[3][1] = M1[0][1] * M2[3][0] + M1[1][1] * M2[3][1] + M1[2][1] * M2[3][2] + M1[3][1];
	M3[3][2] = M1[0][2] * M2[3][0] + M1[1][2] * M2[3][1] + M1[2][2] * M2[3][2] + M1[3][2];
	M3[3][3] = 1.0;
}

// M1 * M2 -> M2
inline void _Multiply(FWMATRIX12 M1, FWMATRIX M2)
{
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE (*m1)[3] = (FWDOUBLE(*)[3])M1;
	FWDOUBLE x0, x1, x2;

	x0 = m1[0][0] * M2[0][0] + m1[1][0] * M2[0][1] + m1[2][0] * M2[0][2];
	x1 = m1[0][1] * M2[0][0] + m1[1][1] * M2[0][1] + m1[2][1] * M2[0][2];
	x2 = m1[0][2] * M2[0][0] + m1[1][2] * M2[0][1] + m1[2][2] * M2[0][2];
	M2[0][0] = x0; M2[0][1] = x1; M2[0][2] = x2;

	x0 = m1[0][0] * M2[1][0] + m1[1][0] * M2[1][1] + m1[2][0] * M2[1][2];
	x1 = m1[0][1] * M2[1][0] + m1[1][1] * M2[1][1] + m1[2][1] * M2[1][2];
	x2 = m1[0][2] * M2[1][0] + m1[1][2] * M2[1][1] + m1[2][2] * M2[1][2];
	M2[1][0] = x0; M2[1][1] = x1; M2[1][2] = x2;

	x0 = m1[0][0] * M2[2][0] + m1[1][0] * M2[2][1] + m1[2][0] * M2[2][2];
	x1 = m1[0][1] * M2[2][0] + m1[1][1] * M2[2][1] + m1[2][1] * M2[2][2];
	x2 = m1[0][2] * M2[2][0] + m1[1][2] * M2[2][1] + m1[2][2] * M2[2][2];
	M2[2][0] = x0; M2[2][1] = x1; M2[2][2] = x2;

	x0 = m1[0][0] * M2[3][0] + m1[1][0] * M2[3][1] + m1[2][0] * M2[3][2] + m1[3][0];
	x1 = m1[0][1] * M2[3][0] + m1[1][1] * M2[3][1] + m1[2][1] * M2[3][2] + m1[3][1];
	x2 = m1[0][2] * M2[3][0] + m1[1][2] * M2[3][1] + m1[2][2] * M2[3][2] + m1[3][2];
	M2[3][0] = x0; M2[3][1] = x1; M2[3][2] = x2;
}

// M1 * M2 -> M2
inline void _Multiply(FWMATRIX9 M1, FWMATRIX M2)
{
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE x0, x1, x2;

	x0 = M1[0][0] * M2[0][0] + M1[1][0] * M2[0][1] + M1[2][0] * M2[0][2];
	x1 = M1[0][1] * M2[0][0] + M1[1][1] * M2[0][1] + M1[2][1] * M2[0][2];
	x2 = M1[0][2] * M2[0][0] + M1[1][2] * M2[0][1] + M1[2][2] * M2[0][2];
	M2[0][0] = x0; M2[0][1] = x1; M2[0][2] = x2;

	x0 = M1[0][0] * M2[1][0] + M1[1][0] * M2[1][1] + M1[2][0] * M2[1][2];
	x1 = M1[0][1] * M2[1][0] + M1[1][1] * M2[1][1] + M1[2][1] * M2[1][2];
	x2 = M1[0][2] * M2[1][0] + M1[1][2] * M2[1][1] + M1[2][2] * M2[1][2];
	M2[1][0] = x0; M2[1][1] = x1; M2[1][2] = x2;

	x0 = M1[0][0] * M2[2][0] + M1[1][0] * M2[2][1] + M1[2][0] * M2[2][2];
	x1 = M1[0][1] * M2[2][0] + M1[1][1] * M2[2][1] + M1[2][1] * M2[2][2];
	x2 = M1[0][2] * M2[2][0] + M1[1][2] * M2[2][1] + M1[2][2] * M2[2][2];
	M2[2][0] = x0; M2[2][1] = x1; M2[2][2] = x2;

	x0 = M1[0][0] * M2[3][0] + M1[1][0] * M2[3][1] + M1[2][0] * M2[3][2];
	x1 = M1[0][1] * M2[3][0] + M1[1][1] * M2[3][1] + M1[2][1] * M2[3][2];
	x2 = M1[0][2] * M2[3][0] + M1[1][2] * M2[3][1] + M1[2][2] * M2[3][2];
	M2[3][0] = x0; M2[3][1] = x1; M2[3][2] = x2;
}

// obsolete
inline void _MultiplyTransposed(FWMATRIX M1, FWMATRIX M2)
{
	assert(M1[3][0] == 0 && M1[3][1] == 0 && M1[3][2] == 0 && M1[3][3] == 1);
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE x0, x1, x2;

	x0 = M1[0][0] * M2[0][0] + M1[0][1] * M2[0][1] + M1[0][2] * M2[0][2];
	x1 = M1[1][0] * M2[0][0] + M1[1][1] * M2[0][1] + M1[1][2] * M2[0][2];
	x2 = M1[2][0] * M2[0][0] + M1[2][1] * M2[0][1] + M1[2][2] * M2[0][2];
	M2[0][0] = x0; M2[0][1] = x1; M2[0][2] = x2;

	x0 = M1[0][0] * M2[1][0] + M1[0][1] * M2[1][1] + M1[0][2] * M2[1][2];
	x1 = M1[1][0] * M2[1][0] + M1[1][1] * M2[1][1] + M1[1][2] * M2[1][2];
	x2 = M1[2][0] * M2[1][0] + M1[2][1] * M2[1][1] + M1[2][2] * M2[1][2];
	M2[1][0] = x0; M2[1][1] = x1; M2[1][2] = x2;

	x0 = M1[0][0] * M2[2][0] + M1[0][1] * M2[2][1] + M1[0][2] * M2[2][2];
	x1 = M1[1][0] * M2[2][0] + M1[1][1] * M2[2][1] + M1[1][2] * M2[2][2];
	x2 = M1[2][0] * M2[2][0] + M1[2][1] * M2[2][1] + M1[2][2] * M2[2][2];
	M2[2][0] = x0; M2[2][1] = x1; M2[2][2] = x2;

	x0 = M1[0][0] * M2[3][0] + M1[0][1] * M2[3][1] + M1[0][2] * M2[3][2] + M1[0][3];
	x1 = M1[1][0] * M2[3][0] + M1[1][1] * M2[3][1] + M1[1][2] * M2[3][2] + M1[1][3];
	x2 = M1[2][0] * M2[3][0] + M1[2][1] * M2[3][1] + M1[2][2] * M2[3][2] + M1[2][3];
	M2[3][0] = x0; M2[3][1] = x1; M2[3][2] = x2;
}

// obsolete
inline void _MultiplyTransposed(FWMATRIX12 M1, FWMATRIX M2)
{
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE (*m1)[3] = (FWDOUBLE(*)[3])M1;
	FWDOUBLE x0, x1, x2;

	x0 = m1[0][0] * M2[0][0] + m1[0][1] * M2[0][1] + m1[0][2] * M2[0][2];
	x1 = m1[1][0] * M2[0][0] + m1[1][1] * M2[0][1] + m1[1][2] * M2[0][2];
	x2 = m1[2][0] * M2[0][0] + m1[2][1] * M2[0][1] + m1[2][2] * M2[0][2];
	M2[0][0] = x0; M2[0][1] = x1; M2[0][2] = x2;

	x0 = m1[0][0] * M2[1][0] + m1[0][1] * M2[1][1] + m1[0][2] * M2[1][2];
	x1 = m1[1][0] * M2[1][0] + m1[1][1] * M2[1][1] + m1[1][2] * M2[1][2];
	x2 = m1[2][0] * M2[1][0] + m1[2][1] * M2[1][1] + m1[2][2] * M2[1][2];
	M2[1][0] = x0; M2[1][1] = x1; M2[1][2] = x2;

	x0 = m1[0][0] * M2[2][0] + m1[0][1] * M2[2][1] + m1[0][2] * M2[2][2];
	x1 = m1[1][0] * M2[2][0] + m1[1][1] * M2[2][1] + m1[1][2] * M2[2][2];
	x2 = m1[2][0] * M2[2][0] + m1[2][1] * M2[2][1] + m1[2][2] * M2[2][2];
	M2[2][0] = x0; M2[2][1] = x1; M2[2][2] = x2;

	x0 = m1[0][0] * M2[3][0] + m1[0][1] * M2[3][1] + m1[0][2] * M2[3][2] + m1[0][3];
	x1 = m1[1][0] * M2[3][0] + m1[1][1] * M2[3][1] + m1[1][2] * M2[3][2] + m1[1][3];
	x2 = m1[2][0] * M2[3][0] + m1[2][1] * M2[3][1] + m1[2][2] * M2[3][2] + m1[2][3];
	M2[3][0] = x0; M2[3][1] = x1; M2[3][2] = x2;
}

// obsolete
inline void _MultiplyTransposed(FWMATRIX9 M1, FWMATRIX M2)
{
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE x0, x1, x2;

	x0 = M1[0][0] * M2[0][0] + M1[0][1] * M2[0][1] + M1[0][2] * M2[0][2];
	x1 = M1[1][0] * M2[0][0] + M1[1][1] * M2[0][1] + M1[1][2] * M2[0][2];
	x2 = M1[2][0] * M2[0][0] + M1[2][1] * M2[0][1] + M1[2][2] * M2[0][2];
	M2[0][0] = x0; M2[0][1] = x1; M2[0][2] = x2;

	x0 = M1[0][0] * M2[1][0] + M1[0][1] * M2[1][1] + M1[0][2] * M2[1][2];
	x1 = M1[1][0] * M2[1][0] + M1[1][1] * M2[1][1] + M1[1][2] * M2[1][2];
	x2 = M1[2][0] * M2[1][0] + M1[2][1] * M2[1][1] + M1[2][2] * M2[1][2];
	M2[1][0] = x0; M2[1][1] = x1; M2[1][2] = x2;

	x0 = M1[0][0] * M2[2][0] + M1[0][1] * M2[2][1] + M1[0][2] * M2[2][2];
	x1 = M1[1][0] * M2[2][0] + M1[1][1] * M2[2][1] + M1[1][2] * M2[2][2];
	x2 = M1[2][0] * M2[2][0] + M1[2][1] * M2[2][1] + M1[2][2] * M2[2][2];
	M2[2][0] = x0; M2[2][1] = x1; M2[2][2] = x2;

	x0 = M1[0][0] * M2[3][0] + M1[0][1] * M2[3][1] + M1[0][2] * M2[3][2];
	x1 = M1[1][0] * M2[3][0] + M1[1][1] * M2[3][1] + M1[1][2] * M2[3][2];
	x2 = M1[2][0] * M2[3][0] + M1[2][1] * M2[3][1] + M1[2][2] * M2[3][2];
	M2[3][0] = x0; M2[3][1] = x1; M2[3][2] = x2;
}

// (M1^-1) * M2 -> M2
inline void _MultiplyInverted(FWMATRIX M1, FWMATRIX M2)
{
	assert(M1[0][3] == 0 && M1[1][3] == 0 && M1[2][3] == 0 && M1[3][3] == 1);
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE M1_30 = -M1[0][0] * M1[3][0] - M1[0][1] * M1[3][1] - M1[0][2] * M1[3][2];
	FWDOUBLE M1_31 = -M1[1][0] * M1[3][0] - M1[1][1] * M1[3][1] - M1[1][2] * M1[3][2];
	FWDOUBLE M1_32 = -M1[2][0] * M1[3][0] - M1[2][1] * M1[3][1] - M1[2][2] * M1[3][2];

	FWDOUBLE x0, x1, x2;

	x0 = M1[0][0] * M2[0][0] + M1[0][1] * M2[0][1] + M1[0][2] * M2[0][2];
	x1 = M1[1][0] * M2[0][0] + M1[1][1] * M2[0][1] + M1[1][2] * M2[0][2];
	x2 = M1[2][0] * M2[0][0] + M1[2][1] * M2[0][1] + M1[2][2] * M2[0][2];
	M2[0][0] = x0; M2[0][1] = x1; M2[0][2] = x2;

	x0 = M1[0][0] * M2[1][0] + M1[0][1] * M2[1][1] + M1[0][2] * M2[1][2];
	x1 = M1[1][0] * M2[1][0] + M1[1][1] * M2[1][1] + M1[1][2] * M2[1][2];
	x2 = M1[2][0] * M2[1][0] + M1[2][1] * M2[1][1] + M1[2][2] * M2[1][2];
	M2[1][0] = x0; M2[1][1] = x1; M2[1][2] = x2;

	x0 = M1[0][0] * M2[2][0] + M1[0][1] * M2[2][1] + M1[0][2] * M2[2][2];
	x1 = M1[1][0] * M2[2][0] + M1[1][1] * M2[2][1] + M1[1][2] * M2[2][2];
	x2 = M1[2][0] * M2[2][0] + M1[2][1] * M2[2][1] + M1[2][2] * M2[2][2];
	M2[2][0] = x0; M2[2][1] = x1; M2[2][2] = x2;

	x0 = M1[0][0] * M2[3][0] + M1[0][1] * M2[3][1] + M1[0][2] * M2[3][2] + M1_30;
	x1 = M1[1][0] * M2[3][0] + M1[1][1] * M2[3][1] + M1[1][2] * M2[3][2] + M1_31;
	x2 = M1[2][0] * M2[3][0] + M1[2][1] * M2[3][1] + M1[2][2] * M2[3][2] + M1_32;
	M2[3][0] = x0; M2[3][1] = x1; M2[3][2] = x2;
}

// M1 * (M2^-1) -> M1
inline void _MultiplyInvertedR(FWMATRIX M1, FWMATRIX M2)
{
	assert(M1[0][3] == 0 && M1[1][3] == 0 && M1[2][3] == 0 && M1[3][3] == 1);
	assert(M2[0][3] == 0 && M2[1][3] == 0 && M2[2][3] == 0 && M2[3][3] == 1);

	FWDOUBLE x0, x1, x2;

	FWDOUBLE M2_30 = -M2[0][0] * M2[3][0] - M2[0][1] * M2[3][1] - M2[0][2] * M2[3][2];
	FWDOUBLE M2_31 = -M2[1][0] * M2[3][0] - M2[1][1] * M2[3][1] - M2[1][2] * M2[3][2];
	FWDOUBLE M2_32 = -M2[2][0] * M2[3][0] - M2[2][1] * M2[3][1] - M2[2][2] * M2[3][2];

	x0 = M1[0][0] * M2_30 + M1[1][0] * M2_31 + M1[2][0] * M2_32 + M1[3][0];
	x1 = M1[0][1] * M2_30 + M1[1][1] * M2_31 + M1[2][1] * M2_32 + M1[3][1];
	x2 = M1[0][2] * M2_30 + M1[1][2] * M2_31 + M1[2][2] * M2_32 + M1[3][2];
	M1[3][0] = x0; M1[3][1] = x1; M1[3][2] = x2;

	x0 = M1[0][0] * M2[0][0] + M1[1][0] * M2[1][0] + M1[2][0] * M2[2][0];
	x1 = M1[0][0] * M2[0][1] + M1[1][0] * M2[1][1] + M1[2][0] * M2[2][1];
	x2 = M1[0][0] * M2[0][2] + M1[1][0] * M2[1][2] + M1[2][0] * M2[2][2];
	M1[0][0] = x0; M1[1][0] = x1; M1[2][0] = x2;

	x0 = M1[0][1] * M2[0][0] + M1[1][1] * M2[1][0] + M1[2][1] * M2[2][0];
	x1 = M1[0][1] * M2[0][1] + M1[1][1] * M2[1][1] + M1[2][1] * M2[2][1];
	x2 = M1[0][1] * M2[0][2] + M1[1][1] * M2[1][2] + M1[2][1] * M2[2][2];
	M1[0][1] = x0; M1[1][1] = x1; M1[2][1] = x2;

	x0 = M1[0][2] * M2[0][0] + M1[1][2] * M2[1][0] + M1[2][2] * M2[2][0];
	x1 = M1[0][2] * M2[0][1] + M1[1][2] * M2[1][1] + M1[2][2] * M2[2][1];
	x2 = M1[0][2] * M2[0][2] + M1[1][2] * M2[1][2] + M1[2][2] * M2[2][2];
	M1[0][2] = x0; M1[1][2] = x1; M1[2][2] = x2;
}




//	FWMATRIX MI;
//	memcpy(MI, M1, sizeof(FWMATRIX));
//	_InverseOrthogonal(MI);
//	_Multiply(MI, M2);
//}

//inline void _MultiplyInverted(FWMATRIX12 M1, FWMATRIX M2)
//{
//	FWMATRIX12 MI;
//	memcpy(MI, M1, sizeof(FWMATRIX));
//	_InverseOrthogonal(MI);
//	_Multiply(MI, M2);
//}
//
//inline void _MultiplyInverted(FWMATRIX9 M1, FWMATRIX M2)
//{
//	FWMATRIX9 MI;
//	memcpy(MI, M1, sizeof(FWMATRIX));
//	_InverseOrthogonal(MI);
//	_Multiply(MI, M2);
//}

#endif