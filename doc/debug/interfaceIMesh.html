<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IMesh interface Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>IMesh Interface Reference<br>
<small>
[<a class="el" href="group__meshplus.html">MESH+ Module</a>]</small>
</h1><code>import "<a class="el" href="meshplus_8idl-source.html">meshplus.idl</a>";</code>
<p>
<p>Inheritance diagram for IMesh:
<p><center><img src="interfaceIMesh.png" usemap="#IMesh_map" border="0" alt=""></center>
<map name="IMesh_map">
<area href="interfaceIFWUnknown.html" alt="IFWUnknown" shape="rect" coords="0,0,85,24">
</map>
<a href="interfaceIMesh-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
MESH+ Mesh Object. 
<p>
A convenient high-level interface encapsulating much of buffer and mesh related functionality. Represents a mesh consisted of a number of vertices and faces and assists the whole mesh life cycle including initializing buffers, filling them with data, until eventually applying the ready dataset to render the mesh.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshSection">The Mesh Object (IMesh)</a> for details. <p>
Implementation in <a class="el" href="classFreeWillPlus_1_1Mesh.html">FreeWillPlus::Mesh</a> </dd></dl>

<p>

<p>
Definition at line <a class="el" href="meshplus_8idl-source.html#l00463">463</a> of file <a class="el" href="meshplus_8idl-source.html">meshplus.idl</a>.<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Capabilities</div></td></tr>
<tr><td colspan="2"><div class="groupText">Delivers the information deduced from the buffer capabilities.<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> if buffers not initialized </dd></dl>
<dl compact><dt><b>Remarks:</b></dt><dd>The actual buffer format may be different than requested when created the buffers. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z79_0" doxytag="IMesh::GetVertexFormat" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z79_0">GetVertexFormat</a> ([out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *nFormat,[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *nBones,[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *nTextures,[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *nVertexSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Currently used vertex format, calls <a class="el" href="interfaceIMeshVertexBuffer.html#a1">IMeshVertexBuffer::GetFormat</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z79_1" doxytag="IMesh::GetVertexCaps" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z79_1">GetVertexCaps</a> ([in] enum <a class="el" href="group__meshplus.html#ga1">MESH_VERTEXID</a> nFlag,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> nIndex,[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *pOffset,[out, retval] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *pSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Currently used vertex layout, calls <a class="el" href="interfaceIMeshVertexBuffer.html#a2">IMeshVertexBuffer::GetCaps</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z79_2" doxytag="IMesh::GetFaceFormat" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z79_2">GetFaceFormat</a> ([out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *nSizeOfVertexIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Currently used face format, 2 for 16-bit vertex index format, 4 for 32-bit vertex indexs format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z79_3" doxytag="IMesh::SupportsVertexBlending" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z79_3">SupportsVertexBlending</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns S_OK if the vertex buffer supports <a class="el" href="group__meshplus.html#gga2a26">MESH_VERTEX_BONEWEIGHT</a> flag (bone weights); S_FALSE otherwise; see <a class="el" href="group__meshplus.html#MeshVer">Vertex Blending Support</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z79_4" doxytag="IMesh::SupportsIndexedVertexBlending" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z79_4">SupportsIndexedVertexBlending</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns S_OK if the vertex buffer supports <a class="el" href="group__meshplus.html#gga2a26">MESH_VERTEX_BONEWEIGHT</a> and <a class="el" href="group__meshplus.html#gga2a27">MESH_VERTEX_BONEINDEX</a> flags (bone weights &amp; indices); S_FALSE otherwise; see <a class="el" href="group__meshplus.html#MeshVer">Vertex Blending Support</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z79_5" doxytag="IMesh::SupportsSubmeshedVertexBlending" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z79_5">SupportsSubmeshedVertexBlending</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns S_OK if the vertex buffer supports the <a class="el" href="group__meshplus.html#gga2a26">MESH_VERTEX_BONEWEIGHT</a> flag but not the <a class="el" href="group__meshplus.html#gga2a27">MESH_VERTEX_BONEINDEX</a> flags (bone weights &amp; indices); S_FALSE otherwise; see <a class="el" href="group__meshplus.html#MeshSub">Submeshes</a> <br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Properties: Visibility</div></td></tr>
<tr><td colspan="2"><div class="groupText">Determines the visibility of the mesh <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z80_0" doxytag="IMesh::IsVisible" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z80_0">IsVisible</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns S_OK if the mesh is visible (switched on); S_FALSE otherwise. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z80_1" doxytag="IMesh::PutVisible" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z80_1">PutVisible</a> (BOOL bOn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switches the mesh visibility on or off. <br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Properties: Used Buffer Range</div></td></tr>
<tr><td colspan="2"><div class="groupText">Delivers information on the position and size of data stored in the vertex &amp; face buffers.<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> if buffers not initialized </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z81_0" doxytag="IMesh::GetVertexFirst" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z81_0">GetVertexFirst</a> ([out, retval] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index of the first allocated vertex position. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z81_1" doxytag="IMesh::GetVertexNum" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z81_1">GetVertexNum</a> ([out, retval] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the allocated vertex range. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z81_2" doxytag="IMesh::GetVertexItemSize" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z81_2">GetVertexItemSize</a> ([out, retval] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of a single Vertex item. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z81_3" doxytag="IMesh::GetFaceFirst" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z81_3">GetFaceFirst</a> ([out, retval] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index of the first allocated face position. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z81_4" doxytag="IMesh::GetFaceNum" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z81_4">GetFaceNum</a> ([out, retval] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the allocated face range. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z81_5" doxytag="IMesh::GetFaceItemSize" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z81_5">GetFaceItemSize</a> ([out, retval] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of a single Face item. <br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh Transformation</div></td></tr>
<tr><td colspan="2"><div class="groupText">Use Mesh Transform to initially, automatically transform all the vertex coordinates passed to <a class="el" href="interfaceIMesh.html#z85_0">IMesh::SetVertexXYZ</a> and <a class="el" href="interfaceIMesh.html#z86_1">IMesh::AddNormal</a> functions.<p>
No other data will be affected. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z82_0" doxytag="IMesh::GetTransform" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z82_0">GetTransform</a> ([out, retval] <a class="el" href="interfaceITransform.html">ITransform</a> **pVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the Mesh Transform. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z82_1" doxytag="IMesh::PutTransform" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z82_1">PutTransform</a> ([in] <a class="el" href="interfaceITransform.html">ITransform</a> *newVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts the Mesh Transform. <br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Dependent Objects: Buffer and Dictionary</div></td></tr>
<tr><td colspan="2"><div class="groupText">Notice that buffers and the dictionary are assigned automatically when <a class="el" href="interfaceISceneObject.html#z97_1">ISceneObject::AddMesh</a> and <a class="el" href="interfaceISceneObject.html#z97_0">ISceneObject::NewMesh</a> are called, thus these properties will rarely be used directly <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z83_0" doxytag="IMesh::GetBuffers" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z83_0">GetBuffers</a> ([out] <a class="el" href="interfaceIMeshVertexBuffer.html">IMeshVertexBuffer</a> **,[out] <a class="el" href="interfaceIMeshFaceBuffer.html">IMeshFaceBuffer</a> **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves Vertex &amp; Face Buffers. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z83_1" doxytag="IMesh::PutBuffers" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z83_1">PutBuffers</a> ([in] <a class="el" href="interfaceIMeshVertexBuffer.html">IMeshVertexBuffer</a> *,[in] <a class="el" href="interfaceIMeshFaceBuffer.html">IMeshFaceBuffer</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets Vertex &amp; Face Buffers. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z83_2" doxytag="IMesh::IsReady" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z83_2">IsReady</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">S_OK if both buffers set; S_FALSE if any buffer is still NULL. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z83_3" doxytag="IMesh::GetDictionary" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z83_3">GetDictionary</a> ([out, retval] <a class="el" href="interfaceIMeshDictionary.html">IMeshDictionary</a> **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves <a class="el" href="interfaceIMeshDictionary.html">IMeshDictionary</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z83_4" doxytag="IMesh::PutDictionary" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z83_4">PutDictionary</a> ([in] <a class="el" href="interfaceIMeshDictionary.html">IMeshDictionary</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets <a class="el" href="interfaceIMeshDictionary.html">IMeshDictionary</a>. <br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Opening and Closing</div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z84_0">Open</a> ([out] BYTE **pVertexBytes,[out] BYTE **pFaceBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives access to the raw data; opens both vertex and face buffers to be filled with data <a class="el" href="interfaceIMesh.html#z84_0">(details)</a>.  <a href="#z84_0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z84_1">Close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should be called once after <a class="el" href="interfaceIMesh.html#z84_0">Open</a> call to release any memory allocated and save the buffer contents <a class="el" href="interfaceIMesh.html#z84_1">(details)</a>.  <a href="#z84_1"></a><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">General Data Support</div></td></tr>
<tr><td colspan="2"><div class="groupText">Functions for quick and easy setting the xyz, colouring, point size and texture attributes for vertices<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshGen">General Data Support</a> </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> (buffers not initialized or <a class="el" href="interfaceIMesh.html#z84_0">IMesh::Open</a> not called), <a class="el" href="group__common__interfaces.html#gga0a40">FW_E_MEMOVERRUN</a>, <a class="el" href="group__common__interfaces.html#gga0a37">FW_E_FORMAT</a> </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_0" doxytag="IMesh::SetVertexXYZ" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z85_0">SetVertexXYZ</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertex,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> x,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> y,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the XYZ data for the iVertex'th vertex; return values - see above. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_1" doxytag="IMesh::SetVertexXYZVector" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z85_1">SetVertexXYZVector</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertex,[in] <a class="el" href="structFWVECTOR3.html">FWVECTOR</a> v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The same as <a class="el" href="interfaceIMesh.html#z85_0">SetVertexXYZ</a>; FWVECTOR param used in place of x, y, z. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_2" doxytag="IMesh::SetVertexPointSize" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z85_2">SetVertexPointSize</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertex,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the PointSize data for the iVertex'th vertex; return values - see above. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_3" doxytag="IMesh::SetVertexDiffuse" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z85_3">SetVertexDiffuse</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertex,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the Diffuse Colour data for the iVertex'th vertex; return values - see above. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_4" doxytag="IMesh::SetVertexSpecular" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z85_4">SetVertexSpecular</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertex,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the Specular Colour data for the iVertex'th vertex; return values - see above. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_5" doxytag="IMesh::SetVertexTexture" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z85_5">SetVertexTexture</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertex,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iTexture,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the Texture data (index &amp; value) for the iVertex'th vertex; return values - see above. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_6" doxytag="IMesh::SetVertexTextureUV" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><b>SetVertexTextureUV</b> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertex,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iTexture,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> u,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> v)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_7" doxytag="IMesh::SetFace" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z85_7">SetFace</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iFace,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertexA,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertexB,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertexC)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the data for the iFace'th face; return values - see above. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_8" doxytag="IMesh::SetMaterial" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><b>SetMaterial</b> ([in] <a class="el" href="interfaceIMaterial.html">IMaterial</a> *pMaterial)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z85_9" doxytag="IMesh::GetMaterial" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><b>GetMaterial</b> ([out, retval] <a class="el" href="interfaceIMaterial.html">IMaterial</a> **ppMaterial)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Support for Normal Vectors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshNor">Normal Vector Support</a> </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z86_0">SupportNormal</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> nLimit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the Normal Vector Support <a class="el" href="interfaceIMesh.html#z86_0">(details)</a>.  <a href="#z86_0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z86_1">AddNormal</a> ([in, out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *index,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> x,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> y,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the normal value for a given vertex <a class="el" href="interfaceIMesh.html#z86_1">(details)</a>.  <a href="#z86_1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="z86_2" doxytag="IMesh::AddNormalVector" ></a>
HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z86_2">AddNormalVector</a> ([in, out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *index,[in] <a class="el" href="structFWVECTOR3.html">FWVECTOR</a> v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The same as <a class="el" href="interfaceIMesh.html#z86_1">AddNormal</a>; FWVECTOR param used in place of x, y, z. <br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Support for Weight Blending</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshVer">Vertex Blending Support</a> </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z87_0">SupportBlendWeight</a> ([in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> fMinWeight,[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> nMinVertexNum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the Vertex Blending Support.  <a href="#z87_0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z87_1">AddBlendWeight</a> ([in] <a class="el" href="group__common__types.html#ga5">FWULONG</a> iVertex,[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a> fWeight,[in, string] LPOLESTR pBoneName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the bone weight for the given vertex.  <a href="#z87_1"></a><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Submesh Info for Rendering</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshRndr">Remarks on Mesh Rendering</a> </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>HRESULT&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIMesh.html#z88_0">GetSubmeshInfo</a> ([out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *pnSubmeshNum,[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *pnBoneNum,[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> **pSubmeshLen,[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> **pSubmeshBones)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns detailed information on submeshes.  <a href="#z88_0"></a><br><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z84_0" doxytag="IMesh::Open" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> HRESULT IMesh::Open           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">[out] BYTE **&nbsp;</td>
          <td class="mdname" nowrap> <em>pVertexBytes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[out] BYTE **&nbsp;</td>
          <td class="mdname" nowrap> <em>pFaceBytes</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gives access to the raw data; opens both vertex and face buffers to be filled with data <a class="el" href="interfaceIMesh.html#z84_0">(details)</a>. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>pVertexBytes</em>&nbsp;</td><td>vertex buffer bytes </td></tr>
    <tr><td></td><td valign=top><em>pFaceBytes</em>&nbsp;</td><td>face buffer bytes </td></tr>
  </table>
</dl>
<dl compact><dt><b>Remarks:</b></dt><dd>If only high-level data functions will be used, the actual pointers to byte buffers may be unwanted; thus you can call <a class="el" href="interfaceIMesh.html#z84_0">Open(NULL, NULL)</a>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>VertexNum, FaceNum (size of the available buffers) </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> if buffers not initialized </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z84_1" doxytag="IMesh::Close" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> HRESULT IMesh::Close           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Should be called once after <a class="el" href="interfaceIMesh.html#z84_0">Open</a> call to release any memory allocated and save the buffer contents <a class="el" href="interfaceIMesh.html#z84_1">(details)</a>. 
<p>
This function also terminates the <a class="el" href="group__meshplus.html#MeshVer">Vertex Blending Support</a> if <a class="el" href="interfaceIMesh.html#z87_0">SupportBlendWeight</a> had been called. <dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a40">FW_E_MEMOVERRUN</a> or E_NOTIMPL if final blending support unsuccessfull. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z86_0" doxytag="IMesh::SupportNormal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> HRESULT IMesh::SupportNormal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nLimit</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes the Normal Vector Support <a class="el" href="interfaceIMesh.html#z86_0">(details)</a>. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshNor">Normal Vector Support</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>nLimit</em>&nbsp;</td><td>determines the size of the Normal Control Structure (see below); 0 for the maximum size </td></tr>
  </table>
</dl>
<dl compact><dt><b>Remarks:</b></dt><dd>Creates the Normal Control Structure that is used by <a class="el" href="interfaceIMesh.html#z86_1">AddNormal</a> to locate all the clones of a given vertex and to determine if cloning is needed (see <a class="el" href="group__meshplus.html#MeshNor">Normal Vector Support</a>). You can control the size of this structure with nLimit parameter; it shoould not be less than the actual number of vertices, <a class="el" href="interfaceIMesh.html#z81_1">GetVertexNum</a>. Set nParam = 0 to cover the maximum length of the buffer or alternatively you can pass a value corresponding to the expected number of vertex clones. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The Normal Control Structure will be deleted during <a class="el" href="interfaceIMesh.html#z84_1">Close</a> call. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li><a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> if buffers not initialized or <a class="el" href="interfaceIMesh.html#z84_0">Open</a> not called.</li><li>FW_E_INVALIDARG if nLimit to small (less then <a class="el" href="interfaceIMesh.html#z81_1">GetVertexNum</a>).</li><li><a class="el" href="group__common__interfaces.html#gga0a40">FW_E_MEMOVERRUN</a> if nLimit to large (overruns the size of the vertex buffer)</li><li>FW_E_OUTOFMEMORY if the Normal Control Structure cannot be created. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z86_1" doxytag="IMesh::AddNormal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> HRESULT IMesh::AddNormal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">[in, out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds the normal value for a given vertex <a class="el" href="interfaceIMesh.html#z86_1">(details)</a>. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshNor">Normal Vector Support</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>index</em>&nbsp;</td><td>The index of the vertex for which a normal is added </td></tr>
    <tr><td></td><td valign=top><em>x,y,z</em>&nbsp;</td><td>The normal coordinates </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>index</em>&nbsp;</td><td>The index of the actual vertex assigned to the given normal (see below) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> if buffers not initialized or <a class="el" href="interfaceIMesh.html#z84_0">Open</a> not called or <a class="el" href="interfaceIMesh.html#z86_0">SupportNormal</a> not called. <p>
<a class="el" href="group__common__interfaces.html#gga0a40">FW_E_MEMOVERRUN</a> if a cloned vertex overrun the vertex buffer. </dd></dl>
<dl compact><dt><b>Remarks:</b></dt><dd><ul>
<li>If the index'th vertex is not assigned to any normal, [x,y,z] is set as its normal; index remains unchanged.</li><li>If the index'th vertex already has the normal, and it is equal to [x,y,z], nothing is done; index remains unchanged.</li><li>If the index'th vertex already has the normal, but it is not equal to [x,y,z], all its clones (if any) are browsed:<ul>
<li>if any clone has the normal equal to [x,y,z] index is assigned its index.</li><li>if there's no such clone, a new clone is created; [x,y,z] is set as its normal; index is assigned to its index. </li></ul>
</li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z87_0" doxytag="IMesh::SupportBlendWeight" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> HRESULT IMesh::SupportBlendWeight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fMinWeight</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nMinVertexNum</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes the Vertex Blending Support. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshVer">Vertex Blending Support</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>fMinWeight</em>&nbsp;</td><td>Threshold value under which bone weights will be ignored (suggested value: 0.01f) </td></tr>
    <tr><td></td><td valign=top><em>nMinVertexNum</em>&nbsp;</td><td>- Expected number of vertices, or 0 when no new vertices expected - see remark below </td></tr>
  </table>
</dl>
<dl compact><dt><b>Remarks:</b></dt><dd>Creates the Weight Control Structure that is used by <a class="el" href="interfaceIMesh.html#z87_1">AddBlendWeight</a> to temporarily store blending data. You can control the size of this data by nMinVertexNum param; the actual size is the max of nMinVertexNum and the current number of vertices. If no more vertices are expected leave this param as 0. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The actual blending data will be copied to the buffers during <a class="el" href="interfaceIMesh.html#z84_1">Close</a>. The Weight Control Structure will be also deleted then. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> if buffers not initialized or <a class="el" href="interfaceIMesh.html#z84_0">Open</a> not called. <p>
<a class="el" href="group__common__interfaces.html#gga0a37">FW_E_FORMAT</a> if the vertex format does not contain blending data (<a class="el" href="group__meshplus.html#gga2a26">MESH_VERTEX_BONEWEIGHT</a>) or too few bones have been declared </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z87_1" doxytag="IMesh::AddBlendWeight" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> HRESULT IMesh::AddBlendWeight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">[in] <a class="el" href="group__common__types.html#ga5">FWULONG</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>iVertex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[in] <a class="el" href="group__common__types.html#ga0">FWFLOAT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fWeight</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[in, string] LPOLESTR&nbsp;</td>
          <td class="mdname" nowrap> <em>pBoneName</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds the bone weight for the given vertex. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshVer">Vertex Blending Support</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>iVertex</em>&nbsp;</td><td>Vertex index </td></tr>
    <tr><td></td><td valign=top><em>fWeight</em>&nbsp;</td><td>The bone weight (0..1) </td></tr>
    <tr><td></td><td valign=top><em>pBoneName</em>&nbsp;</td><td>The bone name </td></tr>
  </table>
</dl>
<dl compact><dt><b>Remarks:</b></dt><dd>The <a class="el" href="group__meshplus.html#MeshVer">Vertex Blending Support</a> engine automatically assigns a unique index to each bone name. Least significant bones may be ignored, regarding hardware capabilities. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> if if buffers not initialized or <a class="el" href="interfaceIMesh.html#z84_0">Open</a> not called or <a class="el" href="interfaceIMesh.html#z87_0">SupportBlendWeight</a> not called. <p>
<a class="el" href="group__common__interfaces.html#gga0a40">FW_E_MEMOVERRUN</a> if iVertex out of range. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z88_0" doxytag="IMesh::GetSubmeshInfo" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> HRESULT IMesh::GetSubmeshInfo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pnSubmeshNum</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pnBoneNum</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>pSubmeshLen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>[out] <a class="el" href="group__common__types.html#ga5">FWULONG</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>pSubmeshBones</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns detailed information on submeshes. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__meshplus.html#MeshRndr">Remarks on Mesh Rendering</a> </dd></dl>
<dl compact><dt><b>Remarks:</b></dt><dd>First call <a class="el" href="interfaceIMesh.html#z79_5">SupportsSubmeshedVertexBlending</a> to check if the mesh contains any submeshes. This function instructs how to divide the Face Buffer into separate submeshes </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>*pnSubmeshNum</em>&nbsp;</td><td>Total number of submeshes </td></tr>
    <tr><td></td><td valign=top><em>*pnBoneNum</em>&nbsp;</td><td>Total number of bones </td></tr>
    <tr><td></td><td valign=top><em>*pSubmeshLen</em>&nbsp;</td><td>Array of size *pnSubmeshNum: entries contain total number of faces in consecutive submeshes </td></tr>
    <tr><td></td><td valign=top><em>*pSubmeshBones</em>&nbsp;</td><td>Array of size *pnSubmeshNum * *pnBoneNum: entries contain lists of bone indices for each submesh </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__common__interfaces.html#gga0a37">FW_E_FORMAT</a> if no submesh division (<a class="el" href="interfaceIMesh.html#z79_5">SupportsSubmeshedVertexBlending</a> is not S_OK) <p>
<a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a> if <a class="el" href="interfaceIMesh.html#z87_0">SupportBlendWeight</a> not called </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="meshplus_8idl-source.html">meshplus.idl</a></ul>
<hr size="1"><p align=right>
Generated on Fri Nov 25 09:36:38 2011 for FreeWill by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.3.7</address>
</body>
</html>
