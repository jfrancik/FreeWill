<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Common Interfaces</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Common Interfaces</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The FreeWill+ Common Interfaces provide the common base interface <a class="el" href="interfaceIFWUnknown.html">IFWUnknown</a> (to be used instead of IUnknown) and the <a class="el" href="interfaceIFWDevice.html">IFWDevice</a>, the framework fundamental utility class. 
<p>
<h2><a class="anchor" name="StdBase">
Using the Standard Base Interfaces</a></h2>
Like most object- or component-oriented libraries, FreeWill+ has a single interface class serving as an ultimate root for all the hierarchies. <b>Interfaces not derived from <a class="el" href="interfaceIFWUnknown.html">IFWUnknown</a> will not conform the system rules</b>. The root interface covers following essential functionality:<ul>
<li>Access to the central <a class="el" href="interfaceIFWDevice.html">IFWDevice</a> object (see below)</li><li>Cloning, ie. creating a new (uninitialised) object of the same class.</li><li>Class identification (string id as well as unique run-time FWULONG id)</li><li>Support for the class-specific error codes (see <a class="el" href="group__common__interfaces.html#ErrHandling">Error Handling</a> below)</li><li>A facility function to raise an error. The actual error processing is done by <a class="el" href="interfaceIFWDevice.html">IFWDevice</a>.</li></ul>
<h2><a class="anchor" name="FWDev">
The FreeWill+ Device</a></h2>
The <a class="el" href="interfaceIFWDevice.html">IFWDevice</a> is a host object for all the global functionality of the system and is the only object created directly - currently with: <pre><div class="fragment">    <a class="code" href="interfaceIFWDevice.html">IFWDevice</a> *p = NULL;
    CoCreateInstance(CLSID_FWDevice, NULL, CLSCTX_INPROC_SERVER, IID_IFWDevice, (<span class="keywordtype">void</span>**)&amp;p).
</div></pre><p>
The FreeWill+ Device functionality covers following areas:<ul>
<li>Repository for the FreeWill+ Objects</li><li>Object Registration and Tracking</li><li>Handling Errors</li></ul>
<h2><a class="anchor" name="FWCreate">
Creating the FreeWill+ Objects</a></h2>
Besides the root <a class="el" href="interfaceIFWDevice.html">IFWDevice</a> object, all other FreeWill+ objects are normally created using one of the two following ways:<ul>
<li>using <a class="el" href="interfaceIFWDevice.html">IFWDevice</a> repository functions like <a class="el" href="interfaceIFWDevice.html#z42_0">IFWDevice::CreateObject</a> / <a class="el" href="interfaceIFWDevice.html#z42_2">IFWDevice::CreateUnknown</a>. This will be described in detail in the next section.</li><li>using another object of the same class through its <a class="el" href="interfaceIFWUnknown.html#z37_0">IFWUnknown::GetClone</a>/IFWUnknown::Clone function This will create a single instance of the same class as the calling object.</li></ul>
<p>
Creating objects otherwise, eg. by CoCreateInstance or C++ new operator is not recommended and requires the created objects to be registered using <a class="el" href="interfaceIFWDevice.html#z44_0">IFWDevice::RegisterObject</a>.<h2><a class="anchor" name="FWRepo">
IFWDevice Object as the System Repository</a></h2>
Following are the System Repository Functions:<ul>
<li><a class="el" href="interfaceIFWDevice.html#z42_0">IFWDevice::CreateObject</a></li><li><a class="el" href="interfaceIFWDevice.html#z42_1">IFWDevice::CreateObjectEx</a></li><li><a class="el" href="interfaceIFWDevice.html#z42_2">IFWDevice::CreateUnknown</a></li><li><a class="el" href="interfaceIFWDevice.html#z42_3">IFWDevice::CreateUnknownEx</a></li><li><a class="el" href="interfaceIFWDevice.html#z42_4">IFWDevice::CreateContext</a></li></ul>
<p>
To create an object using one of the above functions you have to provide:<ul>
<li>a Noun: a generalised class name</li><li>(optionally) a Verb: detailed specification of the required functionality</li><li>(optionally) a List of Parameters: any additonal information required.</li></ul>
<p>
The CreateObject and CreateObjectEx functions return the pointer of the class specified by the user and in C++ code save additional calls to QueryInterface. In C#, Visual Basic and scripting languages CreateUnknown/CreateUnknownEx may be considered, as in these languages QueryInterface is called automatically behind the scene and the functions do not require to provide the IIDs.<p>
Objects are identified either by a Noun only or by a Noun+Verb pair. If a list of parameters is provided, it will be delivered to the object at its creation stage (see remarks below for the details).<p>
<dl compact><dt><b>Remarks:</b></dt><dd>The Repository Configuration, ie. a hierarchical structure of Nouns, Verbs and their corresponding Classes is stored externally and load in the <a class="el" href="interfaceIFWDevice.html">IFWDevice</a> initialisation. The current implementation uses win32 system registry to store this structure, and CLSID's to hint the system how to create factory objects. This may be easily replaced by a different, win api independent solution (e.g. XML file with explicit dll names) A number of functions is provided in <a class="el" href="interfaceIFWDevice.html">IFWDevice</a> to browse and configure this structure.</dd></dl>
<h2><a class="anchor" name="FWRepoIns">
Object Creation Insight</a></h2>
A call to any of System Repository Functions (see above for the list) instantiates an internal CreateContext object (<a class="el" href="interfaceIFWCreateContext.html">IFWCreateContext</a>) which encapsulates all the data needed to create and initialise this object and controls the whole process. The object gets Noun+Verb position within the repository structure and the parameter list.<p>
First time when called for a given class, the CreateContext creates the initial factory object using the underlying technology (COM+ in the current Win32 implementation) and consequently calls this object as an object factory to create new objects of the given class. Thus, consecutive calls do not involve the underlying technology like COM+. This contributes to better efficiency and portability.<p>
The repository makes it possible to register more than one class for the given Noun+Verb pair. In that case the CreateContext object queries all the classes calling <a class="el" href="interfaceIFWUnknown.html#z38_0">IFWUnknown::QueryFitness</a> for their respective factory objects to determine which class is the best fitted.<p>
When the appropriate class is chosen, the repository calls <a class="el" href="interfaceIFWUnknown.html#z37_0">IFWUnknown::GetClone</a> for the chosen factory object to actually create the object.<p>
The last stage is calling <a class="el" href="interfaceIFWUnknown.html#z38_1">IFWUnknown::Create</a> function for the newly created object to initialise it. The object being initialised may query the corresponding CreateContext to acquire all the necessary data.<p>
In case the object should access the creation parameters it should first call <a class="el" href="interfaceIFWCreateContext.html#a4">IFWCreateContext::EnumParams</a> to create an <a class="el" href="interfaceIFWEnumParams.html">IFWEnumParams</a> instance. A range of QueryXXXX functions maintain type matching, automatic conversion and type checking.<h2><a class="anchor" name="FWReg">
Object Registration and Tracking</a></h2>
Every object created in the FreeWill+ system must be registered with <a class="el" href="interfaceIFWDevice.html#z44_0">IFWDevice::RegisterObject</a> to be supported. Objects created within system repository or cloned are registered automatically. Object created otherwise (unrecommended) must be registered manually.<p>
Failing to register may cause functions like <a class="el" href="interfaceIFWUnknown.html#z36_0">IFWUnknown::GetFWDevice</a>/FWDevice crash.<h2><a class="anchor" name="ErrHandling">
Error Handling</a></h2>
The FreeWill+ handles following types of errors:<ul>
<li>Common Errors, used in all classes, with unique codes (see <a class="el" href="group__common__interfaces.html#ga0">FW_ERROR_CODES</a>),</li><li>Class-Specific Errors, with codes specific and meaningful only inside a class/interface/module,</li><li>Win32 System Errors.</li></ul>
<h3><a class="anchor" name="EH1">
Error Severity</a></h3>
The errors may be at four levels of severity (see <a class="el" href="group__common__interfaces.html#ga1">FW_SEVERITY</a> enumaration). By default, critical and serious errors are treated as <b>severe</b> errors and recoverable errors and warnings are treated as <b>non-severe</b> errors (warnings). This default setting may be changed with <a class="el" href="interfaceIFWDevice.html#z45_11">IFWDevice::PutSevereErrorLevel</a>.<h3><a class="anchor" name="EH2">
Checking Errors Locally</a></h3>
With some limitations, you can check the error code immediately after a function returns.<ul>
<li>Majority of functions return HRESULT codes. To immediately check if a function succeeded or failed use SUCCEEDED or FAILED macros (defined in &lt;winerror.h&gt;) to test its result value. Only severe errors cause functions to fail. Warnings and non-severe errors produce HRESULT values with the most-significant bit clear, meaning the overall function success.</li><li>If the Exception Handling is turned on, functions will never fail, instead the control will be immediately moved to the "catch" error recovery routine. However always test functions for fail conditions as the system should work properly even with Exception Handling switched off.</li><li>Notice that codes of class-specific errors are context-sensible. Outside the class the HRESULT codes may be ambigous (various classes may produce various errors with the same code), so use rather global error checking to get context-free information.</li></ul>
<h3><a class="anchor" name="EH3">
Checking Errors Globally</a></h3>
Global error checking gives a context-free, reliable error information.<ul>
<li>For the global check if any errors occurred use <a class="el" href="interfaceIFWDevice.html#z45_0">IFWDevice::GetStatus</a>. All severe errors change this global status to E_FAIL. Get more information with <a class="el" href="interfaceIFWDevice.html#z45_2">IFWDevice::GetErrorNum</a>.</li><li>Call <a class="el" href="interfaceIFWDevice.html#z45_1">IFWDevice::GetLastError</a> to get full error information. This call will reset the system status, so the next call to <a class="el" href="interfaceIFWDevice.html#z45_0">IFWDevice::GetStatus</a> will return S_OK.</li><li>The <a class="el" href="structFWERROR.html">FWERROR</a> structure obtained from <a class="el" href="interfaceIFWDevice.html#z45_1">IFWDevice::GetLastError</a> contains full info on the error and also a link to the previous error registered in the system, so it may be used as the full system log. Notice that while severe errors are usually detected just after they occurred, warnings will often cumulate in the log.</li></ul>
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Two error codes <a class="el" href="group__common__interfaces.html#gga0a27">FW_E_FREEWILL</a> and <a class="el" href="group__common__interfaces.html#gga0a28">FW_E_BADINTERFACE</a> have special status. Their occurence may often mean that the object was unable to proceed the usual error handling procedure, and they may lack the <a class="el" href="interfaceIFWDevice.html#z45_1">IFWDevice::GetLastError</a> information!</dd></dl>
<h3><a class="anchor" name="EH4">
Early Warning Systems: User Handlers and Exception Handling</a></h3>
Use <a class="el" href="interfaceIFWDevice.html#z45_5">IFWDevice::SetUserErrorHandler</a> to pass a pointer to your own function that will be called each time an error occurred or is recovered in the system. All data will be provided.<p>
Call <a class="el" href="interfaceIFWDevice.html#z45_3">IFWDevice::EnableErrorException</a> to enable the try-catch functionality. Each severe error will cause an exception to be thrown. Use try { ... } catch(FWERROR*e) construction to catch these exceptions. Notice, that the method does not guarantee all memory to be freed; what's more it may affect the system's ability to recover after errors. Use carefully; consider another method of error handling in your release version.<br>
 Notice: <a class="el" href="interfaceIFWDevice.html#z45_3">IFWDevice::EnableErrorException</a> function works with a cumulative counter; TRUE will cause internal counter to increment, FALSE to decrement. The facility becomes active when the counter is not zero; the counter is never decremented below 0.<h3><a class="anchor" name="EH5">
Raising Errors and Recovering</a></h3>
Use following tips when you implement any function:<ul>
<li>Report every new error by calling <a class="el" href="interfaceIFWUnknown.html#z40_0">IFWUnknown::Error</a> (available in every interface).</li><li>If the class reports any class-specific errors it is also required to supply the full information on these errors in <a class="el" href="interfaceIFWUnknown.html#z40_2">IFWUnknown::GetClassError</a>. It will be queried immediately after a class-specific error is reported.</li><li>Notice that outside the class, the class-specific error codes may be ambigous. If you call another class' function which fails with class-specific error, <b>do not propagate</b> the ambigous code, use the reserved code <a class="el" href="group__common__interfaces.html#gga0a30">FW_E_CLASSSPECIFIC</a> instead. The user will still be enabled to call <a class="el" href="interfaceIFWDevice.html#z45_1">IFWDevice::GetLastError</a> and obtain the full, original information.</li><li>If your code causes the system to recover after raising an error, you may want to decrease this error's severity level, or even eradicate the error info. Use <a class="el" href="interfaceIFWDevice.html#z45_9">IFWDevice::Recover</a> function.</li><li>Recovering may fail if <a class="el" href="group__common__interfaces.html#EH4">Exception Handling</a> system is enabled. It may happen that an exception would be thrown or user error handler called before you recover. To avoid this use the following structure to assure you intercept all the exceptions: <pre><div class="fragment">    <span class="keywordflow">try</span> { h = your_function(params); }
    <span class="keywordflow">catch</span>(FW_ERROR *e) { h = e-&gt;nCode; }
</div></pre>This will store the HRESULT in h regardless the exceptions are enabled or disabled. Remember that you are obliged to throw an exception, or simply raise another error in case the system does NOT recover and the error should remain.</li></ul>
<h2><a class="anchor" name="CommImpl">
Implementation Remarks</a></h2>
See the standard implementation class for the FreeWill+ Device: <a class="el" href="classFreeWillPlus_1_1FWDevice.html">FreeWillPlus::FWDevice</a>. This implmentation is unlikely to be replaced in futeure modules. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structFWERROR.html">FWERROR</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The FreeWill+ Error Descriptor.  <a href="structFWERROR.html#_details">More...</a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>interface &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIFWUnknown.html">IFWUnknown</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The FreeWill+ hierarchy root class.  <a href="interfaceIFWUnknown.html#_details">More...</a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>interface &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIFWDevice.html">IFWDevice</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The FreeWill+ Device.  <a href="interfaceIFWDevice.html#_details">More...</a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>interface &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIFWCreateContext.html">IFWCreateContext</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The FreeWill CreateContext Object.  <a href="interfaceIFWCreateContext.html#_details">More...</a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>interface &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="interfaceIFWEnumParams.html">IFWEnumParams</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object Creation Enumeration Object.  <a href="interfaceIFWEnumParams.html#_details">More...</a><br><br></td></tr>
<tr><td colspan=2><br><h2>Common Error Codes</h2></td></tr>
<tr><td colspan=2>Error codes used commonly by all the classes <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__common__interfaces.html#ga0">FW_ERROR_CODES</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a25">FW_E_CLASS_ERRORS</a> =  MAKE_HRESULT(1, FACILITY_ITF, 0x0400), 
<a class="el" href="group__common__interfaces.html#gga0a26">FW_E_COMMON_ERRORS</a> =  MAKE_HRESULT(1, FACILITY_ITF, 0x4000), 
<a class="el" href="group__common__interfaces.html#gga0a27">FW_E_FREEWILL</a> =  FW_E_COMMON_ERRORS, 
<a class="el" href="group__common__interfaces.html#gga0a28">FW_E_BADINTERFACE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a29">FW_E_NOINTERFACE</a>, 
<a class="el" href="group__common__interfaces.html#gga0a30">FW_E_CLASSSPECIFIC</a>, 
<a class="el" href="group__common__interfaces.html#gga0a31">FW_E_CLASS</a>, 
<a class="el" href="group__common__interfaces.html#gga0a32">FW_E_UNIDENTIFIED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a33">FW_E_OUTOFMEMORY</a>, 
<a class="el" href="group__common__interfaces.html#gga0a34">FW_E_POINTER</a>, 
<a class="el" href="group__common__interfaces.html#gga0a35">FW_E_NOTFOUND</a>, 
<a class="el" href="group__common__interfaces.html#gga0a36">FW_E_NOTREADY</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a37">FW_E_FORMAT</a>, 
<a class="el" href="group__common__interfaces.html#gga0a38">FW_E_BADINDEX</a>, 
<a class="el" href="group__common__interfaces.html#gga0a39">FW_E_INVALIDARG</a>, 
<a class="el" href="group__common__interfaces.html#gga0a40">FW_E_MEMOVERRUN</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a41">FW_E_STACKOVERRUN</a>, 
<a class="el" href="group__common__interfaces.html#gga0a42">FW_E_UNKNOWN_NOUN</a>, 
<a class="el" href="group__common__interfaces.html#gga0a43">FW_E_UNKNOWN_NOUN_ID</a>, 
<a class="el" href="group__common__interfaces.html#gga0a44">FW_E_UNKNOWN_VERB</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a45">FW_E_UNKNOWN_VERB_ID</a>, 
<a class="el" href="group__common__interfaces.html#gga0a46">FW_E_UNKNOWN_CLASS</a>, 
<a class="el" href="group__common__interfaces.html#gga0a47">FW_E_UNKNOWN_CLASS_ID</a>, 
<a class="el" href="group__common__interfaces.html#gga0a48">FW_E_PARAM_TYPE_MISMATCH</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a49">FW_E_PARAM_BAD_INTERFACE</a>, 
<a class="el" href="group__common__interfaces.html#gga0a50">FW_E_PARAM_IS_NULL</a>, 
<a class="el" href="group__common__interfaces.html#gga0a51">FW_E_PARAM_BAD_BONE</a>, 
<a class="el" href="group__common__interfaces.html#gga0a52">FW_E_PARAM_NO_BONE_REF</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a53">FW_E_PARAM_NO_BODY_REF</a>, 
<a class="el" href="group__common__interfaces.html#gga0a54">FW_E_NAMED_PARAM_NOT_FOUND</a>, 
<a class="el" href="group__common__interfaces.html#gga0a55">FW_E_TOO_MANY_PARAMS</a>, 
<a class="el" href="group__common__interfaces.html#gga0a56">FW_E_MISSING_PARAMS</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga0a57">FW_E_PARAMS_INCONSISTENT</a>, 
<b>FW_E_PARAM_FIRST</b> =  FW_E_PARAM_TYPE_MISMATCH, 
<b>FW_E_PARAM_LAST</b> =  FW_E_PARAMS_INCONSISTENT
<br>
 }</td></tr>

<tr><td colspan=2><br><h2>Error Severity Levels</h2></td></tr>
<tr><td colspan=2>This enumeration is a collection of values related to error severity levels.<p>
Notice that FW_SEV_WARNING to FW_SEV_CRITICAL are the error severity levels, while the other values are used as specific arguments or flags for some function calls. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__common__interfaces.html#ErrHandling">Error Handling</a> </dd></dl>
<br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__common__interfaces.html#ga1">FW_SEVERITY</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga1a60">FW_SEV_DEFAULT</a> =  0x00, 
<a class="el" href="group__common__interfaces.html#gga1a61">FW_SEV_NOTHING</a> =  0x00, 
<a class="el" href="group__common__interfaces.html#gga1a62">FW_SEV_WARNING</a> =  0x01, 
<a class="el" href="group__common__interfaces.html#gga1a63">FW_SEV_RECOVERABLE</a> =  0x02, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga1a64">FW_SEV_SERIOUS</a> =  0x03, 
<a class="el" href="group__common__interfaces.html#gga1a65">FW_SEV_CRITICAL</a> =  0x04, 
<a class="el" href="group__common__interfaces.html#gga1a66">FW_SEV_MASK</a> =  0xff, 
<a class="el" href="group__common__interfaces.html#gga1a67">FW_SEV_SET_ATLEAST</a> =  0x100, 
<br>
&nbsp;&nbsp;<a class="el" href="group__common__interfaces.html#gga1a68">FW_SEV_SET_ATMOST</a> =  0x200
<br>
 }</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga0" doxytag="common.idl::FW_ERROR_CODES" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="group__common__interfaces.html#ga0">FW_ERROR_CODES</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="gga0a25" doxytag="FW_E_CLASS_ERRORS" ></a>FW_E_CLASS_ERRORS</em>&nbsp;</td><td>
The base code for the class-specific errors. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a26" doxytag="FW_E_COMMON_ERRORS" ></a>FW_E_COMMON_ERRORS</em>&nbsp;</td><td>
The base code for the common errors. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a27" doxytag="FW_E_FREEWILL" ></a>FW_E_FREEWILL</em>&nbsp;</td><td>
Invalid FreeWill+ Object - created outside the FWDevice. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a28" doxytag="FW_E_BADINTERFACE" ></a>FW_E_BADINTERFACE</em>&nbsp;</td><td>
Interface not inherited from <a class="el" href="interfaceIFWUnknown.html">IFWUnknown</a>. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a29" doxytag="FW_E_NOINTERFACE" ></a>FW_E_NOINTERFACE</em>&nbsp;</td><td>
Object does not implement required interface. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a30" doxytag="FW_E_CLASSSPECIFIC" ></a>FW_E_CLASSSPECIFIC</em>&nbsp;</td><td>
Undefined class-specific error (ambigous code). </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a31" doxytag="FW_E_CLASS" ></a>FW_E_CLASS</em>&nbsp;</td><td>
The System could not create object because class implementation is unknown. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a32" doxytag="FW_E_UNIDENTIFIED" ></a>FW_E_UNIDENTIFIED</em>&nbsp;</td><td>
Unidentified error. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a33" doxytag="FW_E_OUTOFMEMORY" ></a>FW_E_OUTOFMEMORY</em>&nbsp;</td><td>
Run out of memory. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a34" doxytag="FW_E_POINTER" ></a>FW_E_POINTER</em>&nbsp;</td><td>
Invalid pointer. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a35" doxytag="FW_E_NOTFOUND" ></a>FW_E_NOTFOUND</em>&nbsp;</td><td>
Object not found. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a36" doxytag="FW_E_NOTREADY" ></a>FW_E_NOTREADY</em>&nbsp;</td><td>
Object is not ready to perform the operation. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a37" doxytag="FW_E_FORMAT" ></a>FW_E_FORMAT</em>&nbsp;</td><td>
Function not supported for this format. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a38" doxytag="FW_E_BADINDEX" ></a>FW_E_BADINDEX</em>&nbsp;</td><td>
Index out of range. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a39" doxytag="FW_E_INVALIDARG" ></a>FW_E_INVALIDARG</em>&nbsp;</td><td>
One or more arguments are invalid. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a40" doxytag="FW_E_MEMOVERRUN" ></a>FW_E_MEMOVERRUN</em>&nbsp;</td><td>
Memory buffer overrun. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a41" doxytag="FW_E_STACKOVERRUN" ></a>FW_E_STACKOVERRUN</em>&nbsp;</td><td>
Memory overrun during a stack POP operation. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a42" doxytag="FW_E_UNKNOWN_NOUN" ></a>FW_E_UNKNOWN_NOUN</em>&nbsp;</td><td>
Unknown noun: s. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a43" doxytag="FW_E_UNKNOWN_NOUN_ID" ></a>FW_E_UNKNOWN_NOUN_ID</em>&nbsp;</td><td>
Unknown noun id: d. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a44" doxytag="FW_E_UNKNOWN_VERB" ></a>FW_E_UNKNOWN_VERB</em>&nbsp;</td><td>
Unknown verb: s. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a45" doxytag="FW_E_UNKNOWN_VERB_ID" ></a>FW_E_UNKNOWN_VERB_ID</em>&nbsp;</td><td>
Unknown verb id: d. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a46" doxytag="FW_E_UNKNOWN_CLASS" ></a>FW_E_UNKNOWN_CLASS</em>&nbsp;</td><td>
Unknown class: s. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a47" doxytag="FW_E_UNKNOWN_CLASS_ID" ></a>FW_E_UNKNOWN_CLASS_ID</em>&nbsp;</td><td>
Unknown class id: d. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a48" doxytag="FW_E_PARAM_TYPE_MISMATCH" ></a>FW_E_PARAM_TYPE_MISMATCH</em>&nbsp;</td><td>
Parameter type mismatch when trying to create an object. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a49" doxytag="FW_E_PARAM_BAD_INTERFACE" ></a>FW_E_PARAM_BAD_INTERFACE</em>&nbsp;</td><td>
Cannot create an object. Parameter does not implement required interface. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a50" doxytag="FW_E_PARAM_IS_NULL" ></a>FW_E_PARAM_IS_NULL</em>&nbsp;</td><td>
Cannot create an object. Parameter in NULL. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a51" doxytag="FW_E_PARAM_BAD_BONE" ></a>FW_E_PARAM_BAD_BONE</em>&nbsp;</td><td>
Cannot create an object. Parameter does not represent any existing bone. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a52" doxytag="FW_E_PARAM_NO_BONE_REF" ></a>FW_E_PARAM_NO_BONE_REF</em>&nbsp;</td><td>
Cannot create an object. Parameter seems to be a bone label but there is no node reference. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a53" doxytag="FW_E_PARAM_NO_BODY_REF" ></a>FW_E_PARAM_NO_BODY_REF</em>&nbsp;</td><td>
Cannot create an object. Parameter seems to be a bone index but there is no body reference. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a54" doxytag="FW_E_NAMED_PARAM_NOT_FOUND" ></a>FW_E_NAMED_PARAM_NOT_FOUND</em>&nbsp;</td><td>
Named parameter not found when trying to create an object. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a55" doxytag="FW_E_TOO_MANY_PARAMS" ></a>FW_E_TOO_MANY_PARAMS</em>&nbsp;</td><td>
Too many parameters when trying to create an object. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a56" doxytag="FW_E_MISSING_PARAMS" ></a>FW_E_MISSING_PARAMS</em>&nbsp;</td><td>
Missing parameters when trying to create an object. </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga0a57" doxytag="FW_E_PARAMS_INCONSISTENT" ></a>FW_E_PARAMS_INCONSISTENT</em>&nbsp;</td><td>
Inconsistent or conflicting paranmeters. </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="common_8idl-source.html#l00419">419</a> of file <a class="el" href="common_8idl-source.html">common.idl</a>.    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="common.idl::FW_SEVERITY" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="group__common__interfaces.html#ga1">FW_SEVERITY</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="gga1a60" doxytag="FW_SEV_DEFAULT" ></a>FW_SEV_DEFAULT</em>&nbsp;</td><td>
default (not overriden) severity level - used in <a class="el" href="interfaceIFWDevice.html#z45_7">IFWDevice::RaiseError</a> and <a class="el" href="interfaceIFWUnknown.html#z40_0">IFWUnknown::Error</a> </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga1a61" doxytag="FW_SEV_NOTHING" ></a>FW_SEV_NOTHING</em>&nbsp;</td><td>
"no error" value, causing <a class="el" href="interfaceIFWDevice.html#z45_9">IFWDevice::Recover</a> function to completely erase error information </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga1a62" doxytag="FW_SEV_WARNING" ></a>FW_SEV_WARNING</em>&nbsp;</td><td>
just a warning, should never stop the animation </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga1a63" doxytag="FW_SEV_RECOVERABLE" ></a>FW_SEV_RECOVERABLE</em>&nbsp;</td><td>
minor recoverable error, should not stop the show unless accuracy is crucial </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga1a64" doxytag="FW_SEV_SERIOUS" ></a>FW_SEV_SERIOUS</em>&nbsp;</td><td>
major error, normally stops the animation, however recoverable if stability is crucial </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga1a65" doxytag="FW_SEV_CRITICAL" ></a>FW_SEV_CRITICAL</em>&nbsp;</td><td>
unrecoverable error, always stops the animation </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga1a66" doxytag="FW_SEV_MASK" ></a>FW_SEV_MASK</em>&nbsp;</td><td>
mask for severity levels (excludes flags) </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga1a67" doxytag="FW_SEV_SET_ATLEAST" ></a>FW_SEV_SET_ATLEAST</em>&nbsp;</td><td>
flag: combined with severity SEV means "severity at SEV level or higher" </td></tr>
<tr><td valign=top><em><a class="anchor" name="gga1a68" doxytag="FW_SEV_SET_ATMOST" ></a>FW_SEV_SET_ATMOST</em>&nbsp;</td><td>
flag: combined with severity SEV means "severity at SEV level or lower" </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="common_8idl-source.html#l00468">468</a> of file <a class="el" href="common_8idl-source.html">common.idl</a>.    </td>
  </tr>
</table>
<hr size="1"><p align=right>
Generated on Fri Nov 25 09:36:39 2011 for FreeWill by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.3.7</address>
</body>
</html>
